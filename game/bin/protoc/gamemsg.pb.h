// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gamemsg.proto

#ifndef PROTOBUF_gamemsg_2eproto__INCLUDED
#define PROTOBUF_gamemsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace unknowngamemessage {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gamemsg_2eproto();
void protobuf_AssignDesc_gamemsg_2eproto();
void protobuf_ShutdownFile_gamemsg_2eproto();

class Mvector2d;
class Mheader;
class Meditparticle;

enum Mheader_Emsgtype {
  Mheader_Emsgtype_EDIT_PARTICLE = 0,
  Mheader_Emsgtype_EDIT_TILEDMAP = 1
};
bool Mheader_Emsgtype_IsValid(int value);
const Mheader_Emsgtype Mheader_Emsgtype_Emsgtype_MIN = Mheader_Emsgtype_EDIT_PARTICLE;
const Mheader_Emsgtype Mheader_Emsgtype_Emsgtype_MAX = Mheader_Emsgtype_EDIT_TILEDMAP;
const int Mheader_Emsgtype_Emsgtype_ARRAYSIZE = Mheader_Emsgtype_Emsgtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mheader_Emsgtype_descriptor();
inline const ::std::string& Mheader_Emsgtype_Name(Mheader_Emsgtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mheader_Emsgtype_descriptor(), value);
}
inline bool Mheader_Emsgtype_Parse(
    const ::std::string& name, Mheader_Emsgtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mheader_Emsgtype>(
    Mheader_Emsgtype_descriptor(), name, value);
}
// ===================================================================

class Mvector2d : public ::google::protobuf::Message {
 public:
  Mvector2d();
  virtual ~Mvector2d();

  Mvector2d(const Mvector2d& from);

  inline Mvector2d& operator=(const Mvector2d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mvector2d& default_instance();

  void Swap(Mvector2d* other);

  // implements Message ----------------------------------------------

  Mvector2d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mvector2d& from);
  void MergeFrom(const Mvector2d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float vx = 1;
  inline bool has_vx() const;
  inline void clear_vx();
  static const int kVxFieldNumber = 1;
  inline float vx() const;
  inline void set_vx(float value);

  // required float vy = 2;
  inline bool has_vy() const;
  inline void clear_vy();
  static const int kVyFieldNumber = 2;
  inline float vy() const;
  inline void set_vy(float value);

  // @@protoc_insertion_point(class_scope:unknowngamemessage.Mvector2d)
 private:
  inline void set_has_vx();
  inline void clear_has_vx();
  inline void set_has_vy();
  inline void clear_has_vy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float vx_;
  float vy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gamemsg_2eproto();
  friend void protobuf_AssignDesc_gamemsg_2eproto();
  friend void protobuf_ShutdownFile_gamemsg_2eproto();

  void InitAsDefaultInstance();
  static Mvector2d* default_instance_;
};
// -------------------------------------------------------------------

class Mheader : public ::google::protobuf::Message {
 public:
  Mheader();
  virtual ~Mheader();

  Mheader(const Mheader& from);

  inline Mheader& operator=(const Mheader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mheader& default_instance();

  void Swap(Mheader* other);

  // implements Message ----------------------------------------------

  Mheader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mheader& from);
  void MergeFrom(const Mheader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Mheader_Emsgtype Emsgtype;
  static const Emsgtype EDIT_PARTICLE = Mheader_Emsgtype_EDIT_PARTICLE;
  static const Emsgtype EDIT_TILEDMAP = Mheader_Emsgtype_EDIT_TILEDMAP;
  static inline bool Emsgtype_IsValid(int value) {
    return Mheader_Emsgtype_IsValid(value);
  }
  static const Emsgtype Emsgtype_MIN =
    Mheader_Emsgtype_Emsgtype_MIN;
  static const Emsgtype Emsgtype_MAX =
    Mheader_Emsgtype_Emsgtype_MAX;
  static const int Emsgtype_ARRAYSIZE =
    Mheader_Emsgtype_Emsgtype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Emsgtype_descriptor() {
    return Mheader_Emsgtype_descriptor();
  }
  static inline const ::std::string& Emsgtype_Name(Emsgtype value) {
    return Mheader_Emsgtype_Name(value);
  }
  static inline bool Emsgtype_Parse(const ::std::string& name,
      Emsgtype* value) {
    return Mheader_Emsgtype_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // required .unknowngamemessage.Mheader.Emsgtype msgtype = 2;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 2;
  inline ::unknowngamemessage::Mheader_Emsgtype msgtype() const;
  inline void set_msgtype(::unknowngamemessage::Mheader_Emsgtype value);

  // @@protoc_insertion_point(class_scope:unknowngamemessage.Mheader)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 uid_;
  int msgtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gamemsg_2eproto();
  friend void protobuf_AssignDesc_gamemsg_2eproto();
  friend void protobuf_ShutdownFile_gamemsg_2eproto();

  void InitAsDefaultInstance();
  static Mheader* default_instance_;
};
// -------------------------------------------------------------------

class Meditparticle : public ::google::protobuf::Message {
 public:
  Meditparticle();
  virtual ~Meditparticle();

  Meditparticle(const Meditparticle& from);

  inline Meditparticle& operator=(const Meditparticle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Meditparticle& default_instance();

  void Swap(Meditparticle* other);

  // implements Message ----------------------------------------------

  Meditparticle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Meditparticle& from);
  void MergeFrom(const Meditparticle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .unknowngamemessage.Mheader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::unknowngamemessage::Mheader& header() const;
  inline ::unknowngamemessage::Mheader* mutable_header();
  inline ::unknowngamemessage::Mheader* release_header();
  inline void set_allocated_header(::unknowngamemessage::Mheader* header);

  // optional .unknowngamemessage.Mvector2d randomemissioninterval = 2;
  inline bool has_randomemissioninterval() const;
  inline void clear_randomemissioninterval();
  static const int kRandomemissionintervalFieldNumber = 2;
  inline const ::unknowngamemessage::Mvector2d& randomemissioninterval() const;
  inline ::unknowngamemessage::Mvector2d* mutable_randomemissioninterval();
  inline ::unknowngamemessage::Mvector2d* release_randomemissioninterval();
  inline void set_allocated_randomemissioninterval(::unknowngamemessage::Mvector2d* randomemissioninterval);

  // optional .unknowngamemessage.Mvector2d lifetime = 3;
  inline bool has_lifetime() const;
  inline void clear_lifetime();
  static const int kLifetimeFieldNumber = 3;
  inline const ::unknowngamemessage::Mvector2d& lifetime() const;
  inline ::unknowngamemessage::Mvector2d* mutable_lifetime();
  inline ::unknowngamemessage::Mvector2d* release_lifetime();
  inline void set_allocated_lifetime(::unknowngamemessage::Mvector2d* lifetime);

  // optional .unknowngamemessage.Mvector2d direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  inline const ::unknowngamemessage::Mvector2d& direction() const;
  inline ::unknowngamemessage::Mvector2d* mutable_direction();
  inline ::unknowngamemessage::Mvector2d* release_direction();
  inline void set_allocated_direction(::unknowngamemessage::Mvector2d* direction);

  // optional .unknowngamemessage.Mvector2d speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline const ::unknowngamemessage::Mvector2d& speed() const;
  inline ::unknowngamemessage::Mvector2d* mutable_speed();
  inline ::unknowngamemessage::Mvector2d* release_speed();
  inline void set_allocated_speed(::unknowngamemessage::Mvector2d* speed);

  // optional .unknowngamemessage.Mvector2d rotation = 6;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 6;
  inline const ::unknowngamemessage::Mvector2d& rotation() const;
  inline ::unknowngamemessage::Mvector2d* mutable_rotation();
  inline ::unknowngamemessage::Mvector2d* release_rotation();
  inline void set_allocated_rotation(::unknowngamemessage::Mvector2d* rotation);

  // optional .unknowngamemessage.Mvector2d rotationspeed = 7;
  inline bool has_rotationspeed() const;
  inline void clear_rotationspeed();
  static const int kRotationspeedFieldNumber = 7;
  inline const ::unknowngamemessage::Mvector2d& rotationspeed() const;
  inline ::unknowngamemessage::Mvector2d* mutable_rotationspeed();
  inline ::unknowngamemessage::Mvector2d* release_rotationspeed();
  inline void set_allocated_rotationspeed(::unknowngamemessage::Mvector2d* rotationspeed);

  // optional .unknowngamemessage.Mvector2d fadetime = 8;
  inline bool has_fadetime() const;
  inline void clear_fadetime();
  static const int kFadetimeFieldNumber = 8;
  inline const ::unknowngamemessage::Mvector2d& fadetime() const;
  inline ::unknowngamemessage::Mvector2d* mutable_fadetime();
  inline ::unknowngamemessage::Mvector2d* release_fadetime();
  inline void set_allocated_fadetime(::unknowngamemessage::Mvector2d* fadetime);

  // optional .unknowngamemessage.Mvector2d scale = 9;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 9;
  inline const ::unknowngamemessage::Mvector2d& scale() const;
  inline ::unknowngamemessage::Mvector2d* mutable_scale();
  inline ::unknowngamemessage::Mvector2d* release_scale();
  inline void set_allocated_scale(::unknowngamemessage::Mvector2d* scale);

  // optional string texname = 10;
  inline bool has_texname() const;
  inline void clear_texname();
  static const int kTexnameFieldNumber = 10;
  inline const ::std::string& texname() const;
  inline void set_texname(const ::std::string& value);
  inline void set_texname(const char* value);
  inline void set_texname(const char* value, size_t size);
  inline ::std::string* mutable_texname();
  inline ::std::string* release_texname();
  inline void set_allocated_texname(::std::string* texname);

  // @@protoc_insertion_point(class_scope:unknowngamemessage.Meditparticle)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_randomemissioninterval();
  inline void clear_has_randomemissioninterval();
  inline void set_has_lifetime();
  inline void clear_has_lifetime();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_rotationspeed();
  inline void clear_has_rotationspeed();
  inline void set_has_fadetime();
  inline void clear_has_fadetime();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_texname();
  inline void clear_has_texname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::unknowngamemessage::Mheader* header_;
  ::unknowngamemessage::Mvector2d* randomemissioninterval_;
  ::unknowngamemessage::Mvector2d* lifetime_;
  ::unknowngamemessage::Mvector2d* direction_;
  ::unknowngamemessage::Mvector2d* speed_;
  ::unknowngamemessage::Mvector2d* rotation_;
  ::unknowngamemessage::Mvector2d* rotationspeed_;
  ::unknowngamemessage::Mvector2d* fadetime_;
  ::unknowngamemessage::Mvector2d* scale_;
  ::std::string* texname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_gamemsg_2eproto();
  friend void protobuf_AssignDesc_gamemsg_2eproto();
  friend void protobuf_ShutdownFile_gamemsg_2eproto();

  void InitAsDefaultInstance();
  static Meditparticle* default_instance_;
};
// ===================================================================


// ===================================================================

// Mvector2d

// required float vx = 1;
inline bool Mvector2d::has_vx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mvector2d::set_has_vx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mvector2d::clear_has_vx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mvector2d::clear_vx() {
  vx_ = 0;
  clear_has_vx();
}
inline float Mvector2d::vx() const {
  return vx_;
}
inline void Mvector2d::set_vx(float value) {
  set_has_vx();
  vx_ = value;
}

// required float vy = 2;
inline bool Mvector2d::has_vy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mvector2d::set_has_vy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mvector2d::clear_has_vy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mvector2d::clear_vy() {
  vy_ = 0;
  clear_has_vy();
}
inline float Mvector2d::vy() const {
  return vy_;
}
inline void Mvector2d::set_vy(float value) {
  set_has_vy();
  vy_ = value;
}

// -------------------------------------------------------------------

// Mheader

// required int32 uid = 1;
inline bool Mheader::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mheader::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mheader::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mheader::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 Mheader::uid() const {
  return uid_;
}
inline void Mheader::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// required .unknowngamemessage.Mheader.Emsgtype msgtype = 2;
inline bool Mheader::has_msgtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mheader::set_has_msgtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mheader::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mheader::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::unknowngamemessage::Mheader_Emsgtype Mheader::msgtype() const {
  return static_cast< ::unknowngamemessage::Mheader_Emsgtype >(msgtype_);
}
inline void Mheader::set_msgtype(::unknowngamemessage::Mheader_Emsgtype value) {
  assert(::unknowngamemessage::Mheader_Emsgtype_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// -------------------------------------------------------------------

// Meditparticle

// required .unknowngamemessage.Mheader header = 1;
inline bool Meditparticle::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Meditparticle::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Meditparticle::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Meditparticle::clear_header() {
  if (header_ != NULL) header_->::unknowngamemessage::Mheader::Clear();
  clear_has_header();
}
inline const ::unknowngamemessage::Mheader& Meditparticle::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::unknowngamemessage::Mheader* Meditparticle::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::unknowngamemessage::Mheader;
  return header_;
}
inline ::unknowngamemessage::Mheader* Meditparticle::release_header() {
  clear_has_header();
  ::unknowngamemessage::Mheader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_header(::unknowngamemessage::Mheader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .unknowngamemessage.Mvector2d randomemissioninterval = 2;
inline bool Meditparticle::has_randomemissioninterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Meditparticle::set_has_randomemissioninterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Meditparticle::clear_has_randomemissioninterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Meditparticle::clear_randomemissioninterval() {
  if (randomemissioninterval_ != NULL) randomemissioninterval_->::unknowngamemessage::Mvector2d::Clear();
  clear_has_randomemissioninterval();
}
inline const ::unknowngamemessage::Mvector2d& Meditparticle::randomemissioninterval() const {
  return randomemissioninterval_ != NULL ? *randomemissioninterval_ : *default_instance_->randomemissioninterval_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::mutable_randomemissioninterval() {
  set_has_randomemissioninterval();
  if (randomemissioninterval_ == NULL) randomemissioninterval_ = new ::unknowngamemessage::Mvector2d;
  return randomemissioninterval_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::release_randomemissioninterval() {
  clear_has_randomemissioninterval();
  ::unknowngamemessage::Mvector2d* temp = randomemissioninterval_;
  randomemissioninterval_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_randomemissioninterval(::unknowngamemessage::Mvector2d* randomemissioninterval) {
  delete randomemissioninterval_;
  randomemissioninterval_ = randomemissioninterval;
  if (randomemissioninterval) {
    set_has_randomemissioninterval();
  } else {
    clear_has_randomemissioninterval();
  }
}

// optional .unknowngamemessage.Mvector2d lifetime = 3;
inline bool Meditparticle::has_lifetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Meditparticle::set_has_lifetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Meditparticle::clear_has_lifetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Meditparticle::clear_lifetime() {
  if (lifetime_ != NULL) lifetime_->::unknowngamemessage::Mvector2d::Clear();
  clear_has_lifetime();
}
inline const ::unknowngamemessage::Mvector2d& Meditparticle::lifetime() const {
  return lifetime_ != NULL ? *lifetime_ : *default_instance_->lifetime_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::mutable_lifetime() {
  set_has_lifetime();
  if (lifetime_ == NULL) lifetime_ = new ::unknowngamemessage::Mvector2d;
  return lifetime_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::release_lifetime() {
  clear_has_lifetime();
  ::unknowngamemessage::Mvector2d* temp = lifetime_;
  lifetime_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_lifetime(::unknowngamemessage::Mvector2d* lifetime) {
  delete lifetime_;
  lifetime_ = lifetime;
  if (lifetime) {
    set_has_lifetime();
  } else {
    clear_has_lifetime();
  }
}

// optional .unknowngamemessage.Mvector2d direction = 4;
inline bool Meditparticle::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Meditparticle::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Meditparticle::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Meditparticle::clear_direction() {
  if (direction_ != NULL) direction_->::unknowngamemessage::Mvector2d::Clear();
  clear_has_direction();
}
inline const ::unknowngamemessage::Mvector2d& Meditparticle::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::unknowngamemessage::Mvector2d;
  return direction_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::release_direction() {
  clear_has_direction();
  ::unknowngamemessage::Mvector2d* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_direction(::unknowngamemessage::Mvector2d* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
}

// optional .unknowngamemessage.Mvector2d speed = 5;
inline bool Meditparticle::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Meditparticle::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Meditparticle::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Meditparticle::clear_speed() {
  if (speed_ != NULL) speed_->::unknowngamemessage::Mvector2d::Clear();
  clear_has_speed();
}
inline const ::unknowngamemessage::Mvector2d& Meditparticle::speed() const {
  return speed_ != NULL ? *speed_ : *default_instance_->speed_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::mutable_speed() {
  set_has_speed();
  if (speed_ == NULL) speed_ = new ::unknowngamemessage::Mvector2d;
  return speed_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::release_speed() {
  clear_has_speed();
  ::unknowngamemessage::Mvector2d* temp = speed_;
  speed_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_speed(::unknowngamemessage::Mvector2d* speed) {
  delete speed_;
  speed_ = speed;
  if (speed) {
    set_has_speed();
  } else {
    clear_has_speed();
  }
}

// optional .unknowngamemessage.Mvector2d rotation = 6;
inline bool Meditparticle::has_rotation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Meditparticle::set_has_rotation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Meditparticle::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Meditparticle::clear_rotation() {
  if (rotation_ != NULL) rotation_->::unknowngamemessage::Mvector2d::Clear();
  clear_has_rotation();
}
inline const ::unknowngamemessage::Mvector2d& Meditparticle::rotation() const {
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::unknowngamemessage::Mvector2d;
  return rotation_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::release_rotation() {
  clear_has_rotation();
  ::unknowngamemessage::Mvector2d* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_rotation(::unknowngamemessage::Mvector2d* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
}

// optional .unknowngamemessage.Mvector2d rotationspeed = 7;
inline bool Meditparticle::has_rotationspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Meditparticle::set_has_rotationspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Meditparticle::clear_has_rotationspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Meditparticle::clear_rotationspeed() {
  if (rotationspeed_ != NULL) rotationspeed_->::unknowngamemessage::Mvector2d::Clear();
  clear_has_rotationspeed();
}
inline const ::unknowngamemessage::Mvector2d& Meditparticle::rotationspeed() const {
  return rotationspeed_ != NULL ? *rotationspeed_ : *default_instance_->rotationspeed_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::mutable_rotationspeed() {
  set_has_rotationspeed();
  if (rotationspeed_ == NULL) rotationspeed_ = new ::unknowngamemessage::Mvector2d;
  return rotationspeed_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::release_rotationspeed() {
  clear_has_rotationspeed();
  ::unknowngamemessage::Mvector2d* temp = rotationspeed_;
  rotationspeed_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_rotationspeed(::unknowngamemessage::Mvector2d* rotationspeed) {
  delete rotationspeed_;
  rotationspeed_ = rotationspeed;
  if (rotationspeed) {
    set_has_rotationspeed();
  } else {
    clear_has_rotationspeed();
  }
}

// optional .unknowngamemessage.Mvector2d fadetime = 8;
inline bool Meditparticle::has_fadetime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Meditparticle::set_has_fadetime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Meditparticle::clear_has_fadetime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Meditparticle::clear_fadetime() {
  if (fadetime_ != NULL) fadetime_->::unknowngamemessage::Mvector2d::Clear();
  clear_has_fadetime();
}
inline const ::unknowngamemessage::Mvector2d& Meditparticle::fadetime() const {
  return fadetime_ != NULL ? *fadetime_ : *default_instance_->fadetime_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::mutable_fadetime() {
  set_has_fadetime();
  if (fadetime_ == NULL) fadetime_ = new ::unknowngamemessage::Mvector2d;
  return fadetime_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::release_fadetime() {
  clear_has_fadetime();
  ::unknowngamemessage::Mvector2d* temp = fadetime_;
  fadetime_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_fadetime(::unknowngamemessage::Mvector2d* fadetime) {
  delete fadetime_;
  fadetime_ = fadetime;
  if (fadetime) {
    set_has_fadetime();
  } else {
    clear_has_fadetime();
  }
}

// optional .unknowngamemessage.Mvector2d scale = 9;
inline bool Meditparticle::has_scale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Meditparticle::set_has_scale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Meditparticle::clear_has_scale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Meditparticle::clear_scale() {
  if (scale_ != NULL) scale_->::unknowngamemessage::Mvector2d::Clear();
  clear_has_scale();
}
inline const ::unknowngamemessage::Mvector2d& Meditparticle::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::unknowngamemessage::Mvector2d;
  return scale_;
}
inline ::unknowngamemessage::Mvector2d* Meditparticle::release_scale() {
  clear_has_scale();
  ::unknowngamemessage::Mvector2d* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void Meditparticle::set_allocated_scale(::unknowngamemessage::Mvector2d* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// optional string texname = 10;
inline bool Meditparticle::has_texname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Meditparticle::set_has_texname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Meditparticle::clear_has_texname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Meditparticle::clear_texname() {
  if (texname_ != &::google::protobuf::internal::kEmptyString) {
    texname_->clear();
  }
  clear_has_texname();
}
inline const ::std::string& Meditparticle::texname() const {
  return *texname_;
}
inline void Meditparticle::set_texname(const ::std::string& value) {
  set_has_texname();
  if (texname_ == &::google::protobuf::internal::kEmptyString) {
    texname_ = new ::std::string;
  }
  texname_->assign(value);
}
inline void Meditparticle::set_texname(const char* value) {
  set_has_texname();
  if (texname_ == &::google::protobuf::internal::kEmptyString) {
    texname_ = new ::std::string;
  }
  texname_->assign(value);
}
inline void Meditparticle::set_texname(const char* value, size_t size) {
  set_has_texname();
  if (texname_ == &::google::protobuf::internal::kEmptyString) {
    texname_ = new ::std::string;
  }
  texname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Meditparticle::mutable_texname() {
  set_has_texname();
  if (texname_ == &::google::protobuf::internal::kEmptyString) {
    texname_ = new ::std::string;
  }
  return texname_;
}
inline ::std::string* Meditparticle::release_texname() {
  clear_has_texname();
  if (texname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = texname_;
    texname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Meditparticle::set_allocated_texname(::std::string* texname) {
  if (texname_ != &::google::protobuf::internal::kEmptyString) {
    delete texname_;
  }
  if (texname) {
    set_has_texname();
    texname_ = texname;
  } else {
    clear_has_texname();
    texname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace unknowngamemessage

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::unknowngamemessage::Mheader_Emsgtype>() {
  return ::unknowngamemessage::Mheader_Emsgtype_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gamemsg_2eproto__INCLUDED
